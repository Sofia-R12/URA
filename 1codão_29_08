//cdigo para sair da casa
// é uma mistura de sensor óptico e ultrassônico
#include <Servo.h>
#include <NewPing.h>

// Sensor linha preta
int pinIrC = 9;
int pinIrD = 12;
int pinIrE = 8;

// Sensores de Cor
int pinCorD = A4;
int pinCorE = A5;

#define BRANCO 0
#define PRETO 1
#define VERDE 10

// Configurações dos pinos
#define TRIG_PIN 9
#define ECHO_PIN 8
#define SERVO_PIN 3

// Motores Frente
int pinoFMDa = 11;
int pinoFMDb = 10;
int pinoFMEa = 6; //ok
int pinoFMEb = 5;//ok

// Distâncias de referência
const int DISTANCIA_SEGURO = 20;
const int DISTANCIA_PARADA = 15;
const int ANGULO_INICIAL = 90;

// Variáveis globais
Servo servo;
NewPing sensor(TRIG_PIN, ECHO_PIN);
int distanciaFrente = 0;
int distanciaDireita = 0;
int distanciaEsquerda = 0;
int angulo = ANGULO_INICIAL;


// Tempo da última leitura
unsigned long ultimaLeitura = 0;
unsigned long leituraAnterior = 0;

 void setup() {
  Serial.begin(9600);
  servo.attach(SERVO_PIN);
  servo.write(ANGULO_INICIAL);

  // Configurar pinos dos motores
  pinMode(pinoFMDa, OUTPUT);
  pinMode(pinoFMDb, OUTPUT);
  pinMode(pinoFMEa, OUTPUT);
  pinMode(pinoFMEb, OUTPUT);

   // Sensor Direito
  pinMode(pinIrD, INPUT);
  // Sensor Central
  pinMode(pinIrC, INPUT);
  // Sensor Esquerdo
  pinMode(pinIrE, INPUT);

}

 void loop() {
  // Ler distância a cada 200ms
  if (millis() - ultimaLeitura >= 200) {
    ultimaLeitura = millis();
    distanciaFrente = lerDistancia();
    
    Serial.print("Distância: ");
    Serial.print(distanciaFrente);
    Serial.println(" cm");
  }

  /* if (~/parar de ler ){
    parar();
    andarFrente();
   leituraAnterior = millis();
    
    if(leituraAnterior- millis() >= 500){
      parar();
      }
    virarEsquerda();
    leituraAnterior = millis();
    
    if (leituraAnterior - millis() >= 1000){
      parar();
      } 
     andarFrente(); 
    }*/

    // Sensor Direito
  int valorLidoD = digitalRead(pinIrD);
  // Sensor Central
  int valorLidoC = digitalRead(pinIrC);
  // Sensor Esquerdo
  int valorLidoE = digitalRead(pinIrE);

  int sensorCorDir = analogRead(pinCorD);
  int sensorCorEsq = analogRead(pinCorE);


  if (valorLidoD == BRANCO && valorLidoC == PRETO && valorLidoE == BRANCO ) {
    frente();
  } 

  // Checa a interseção sem marcação
  /*if (valorLidoD == BRANCO && valorLidoC == PRETO && valorLidoE == BRANCO && sensorCorDir == VERDE || valorLidoD == BRANCO && valorLidoC == PRETO && valorLidoE == BRANCO && sensorCorEsq == VERDE) {
    frente();
  }
  // Checa as interseções com marcação 
  if(valorLidoD == PRETO && valorLidoC == PRETO && valorLidoE == PRETO || valorLidoD == PRETO && valorLidoC == BRANCO && valorLidoE == PRETO){
    
    if(sensorCorDir == VERDE && sensorCorEsq != VERDE){
      direita();
    }
    else if(sensorCorDir != VERDE && sensorCorEsq == VERDE){
      esquerda();
    }
    else if(sensorCorDir != VERDE && sensorCorEsq != VERDE){
      frente();
    }
    else if(sensorCorDir == VERDE && sensorCorEsq == VERDE){
      volta();
      //delay(500);
      frente();
    }

  }*/
  //O carrinho tá desviando pra esquerda
  if (valorLidoD == PRETO && valorLidoC == BRANCO && valorLidoE == BRANCO) {
   virarDireita();
  } 

  //O carrinho tá desviando pra direita
  if (valorLidoD == BRANCO && valorLidoC == BRANCO && valorLidoE == PRETO) {
    virarEsquerda();
  } 

 /* if (valorLidoD == PRETO && valorLidoC == PRETO && valorLidoE == PRETO || valorLidoD == BRANCO && valorLidoC == PRETO && valorLidoE == PRETO || valorLidoD == PRETO && valorLidoC == PRETO && valorLidoE == BRANCO) {
    if(sensorCorDir == VERDE && sensorCorEsq != VERDE){
      direita();
    }

    else if(sensorCorDir != VERDE && sensorCorEsq == VERDE){
      esquerda();
    }
  }*/
}

int lerDistancia() {
 int dist = sensor.ping_cm(); // the read of the sensor according to the library
    if (dist == 0){ // se a dist for 0, ent retornaremos 200. 
      return 200;
    }else{ // se a distância for diferente de 0, vamos retornar a distância medida
      return dist;// fazemos isso pois, as vezes, o sensor retorna 0 quando há uma grande distância.
    }
}

void varrerAmbiente() {
  // Verificar lado esquerdo (90° a 180°)
  for (angulo = 90; angulo <= 180; angulo += 5) {
    servo.write(angulo);
    delay(50);
  }
  distanciaEsquerda = lerDistancia();
  delay(300);
  Serial.print("Esquerda: ");
  Serial.print(distanciaEsquerda);
  Serial.println(" cm");

  // Verificar a frente (180° a 90°)
  for (angulo = 180; angulo >= 90; angulo -= 5) {
    servo.write(angulo);
    delay(50);
  }
  distanciaFrente = lerDistancia();
  delay(300);
  Serial.print("Frente: ");
  Serial.print(distanciaFrente);
  Serial.println(" cm");
  
}

void tomarDecisao() {
  Serial.print("Decisão - F: ");
  Serial.print(distanciaFrente);
  Serial.print(" cm, E: ");
  Serial.print(distanciaEsquerda);
  Serial.println(" cm");

 
  if (distanciaDireita > distanciaEsquerda && distanciaDireita > DISTANCIA_SEGURO) {
    Serial.println("Virando DIREITA");
    virarDireita();
  } else if (distanciaEsquerda > DISTANCIA_SEGURO) {
    Serial.println("Virando ESQUERDA");
    virarEsquerda();
  } else {
    Serial.println("Recuando");
    recuar();
    delay(1000);
    parar();
  }
  
  // Reset das distâncias laterais
  distanciaDireita = 0;
  distanciaEsquerda = 0;
}

// Funções de movimento
void andarFrente() {
  analogWrite(pinoFMDa, 200);
  analogWrite(pinoFMDb, 0);
  analogWrite(pinoFMEa, 200);
  analogWrite(pinoFMEb, 0);
}

void parar() {
  analogWrite(pinoFMDa, 0);
  analogWrite(pinoFMDb, 0);
  analogWrite(pinoFMEa, 0);
  analogWrite(pinoFMEb, 0);

}

void virarDireita() {
  analogWrite(pinoFMDa, 0);
  analogWrite(pinoFMDb, 200);
  analogWrite(pinoFMEa, 200);
  analogWrite(pinoFMEb, 0);

}

void virarEsquerda() {
  analogWrite(pinoFMDa, 200);
  analogWrite(pinoFMDb, 0);
  analogWrite(pinoFMEa, 0);
  analogWrite(pinoFMEb, 200);

}

void recuar() {
  analogWrite(pinoFMDa, 200);
  analogWrite(pinoFMDb, 0);
  analogWrite(pinoFMEa, 0);
  analogWrite(pinoFMEb, 200);
}
